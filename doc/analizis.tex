\section{Аналитический раздел}

\subsection{Постановка задачи}
В соответствии с техническим заданием на курсовой проект необходимо разработать
программное обеспечение, позволяющее использовать дополнительную цифровую клавиатуру
для ввода текста.
\begin{itemize}
	\item Программное обеспечение должно переопределять
		набор цифровых клавиш дополнительной клавиатуры;
	\item Программное обеспечение должно позволять вводить несколько
		различных символов при нажатии на одну и ту же клавишу дополнительной
		цифровой клавиатуры;
	\item Программное обеспечение должно учитывать число нажатий клавиши
		и время отсутствия нажатия;
	\item Программное обеспечение не должно нарушать или замедлять работу системы.
\end{itemize}

Поставленную задачу нельзя решить в адрессном пространстве пользователя.
Однако это можно сделать путем написания соответствующего драйвера.

\subsection{Подсистема ввода-вывода}
Подсистема ввода/вывода \linux\ обеспечивает простой и универсальный интерфейс 
для устройств, находящихся на плате. Подсистемой ввода/вывода 
поддерживаются три вида устройств:
\begin{itemize}
	\item Символьные устройства для поддержки последовательных устройств;
	\item Блочные устройства для поддержки устройств с произвольным доступом. 
		Блочные устройства имеют важное значение для реализации файловых систем;
	\item Сетевые устройства, которые поддерживают широкий спектр устройств на канальном уровне;
\end{itemize}

Клавиатура относится к классу символьных устройств, где данные передаются посимвольно.
\newpar

Управление работой клавиатуры в текстовом режиме осуществляется драйвером терминала, который входит в состав ядра \linux.
Драйвер терминала состоит из двух отдельных драйверов: драйвера клавиатуры и драйвера экрана. Драйвер
клавиатуры обрабатывает нажатия клавиш пользователем и передает результат прикладной программе, которая, в
свою очередь, посылает экранному драйверу символы которые должны быть отображены на экране.
При каждом нажатии на клавишу микропроцессор клавиатуры генерирует последовательность скан-кодов, которая представляет
собой набор из двух или больше числа байтов.
Эта последовательность передается драйверу клавиатуры, который может работать в одном из четырех режимов:

\begin{itemize}
	\item K\_ROW, когда прикладной программе передается последовательность скан-кодов, сгенерированных клавиатурой.
		Этот режим используется при работе с приложениями, которые имеют свой собственный драйвер клавиатуры. Примером
		такого приложения является система \linuxcommand{XWindow}.
	\item K\_MEDIUMRAW, когда скан-код клавишт преобразуется в один из 127 возможных кодов, называемых кодами клавиш (keycodes).
		Каждый код клавиши состоит из кода нажатия клавиши и кода отпускания клавиши. Преобразование скан-кодов
		в коды клавиш осуществляется в соответствии с внутренней таблицей драйвера клавиатуры. Обычно, 
		эта таблица фиксирована, и изменять ее не требуется, хотя в системе существуеткоманды \linuxcommand{getkeycodes} и 
		\linuxcommand{setkeycodes}, с помощью которых можно просмотреть или изменить некоторые соответствия в этой
		таблице. Эти команды используются только в том случае, если клавиатура программируемая.
	\item K\_XLATE (или режим ASCII), когда коды клавиши преобразуются в ASCII-код символа или в некоторую последовательность
		ASCII-кодов символов в соответствии с таблицей раскладки клавиатуры, которая хранится в виде отдельного файла.
		Например, для \fulllinux\ по умолчанию используется файл \linuxpath{defkeymap.map.gz} в 
		каталоге \linuxpath{/usr/share/\-kbd/\-keymaps/\-i386/qwerty}. Команда \linuxcommand{dumpkeys} выводит на экран
		содержание действующей в данный момент таблицы раскладки клавиатуры, а команда \linuxcommand{loadkeys} загружает
		в драйвер таблицу раскладки клавиатуры из указанного файла.
	\item K\_UNICODE, когда скан-коды преобразуются в двухбайтовые коды таблицы UNICODE (этот режим используется редко).
\end{itemize}

Выбор режима работы драйвера терминала определяется прикладной программой, которая в данный момент выполняется
компьютером. Чаще всего используется третий режим, когда код клавиши либо преобразуется в ASCII-код символа или строку таких
кодов в соответствии с таблицей раскладки клавиатуры, либо выполняется действие, определенное для конкретной комбинации клавиш
в таблице раскладки клавиатуры. 
\newpar	

Режим работы драйвера клавиатуры можно узнать или изменить с помощью команды \linuxcommand{kbd-mode}. 
\newpar

Однако не для всех клавиш и комбинаций клавиш процесс обработки происходит так прямолинейно, как это
описано выше. Во-первых, имеется насколько особых клавиш, так называемых клавиш-переключателей.
Это клавиши \key{Shift} (правая и левая), \key{Alt} (правая и левая), \key{Ctrl} (правая и левая), 
\key{Caps Lock}, \key{Num Lock}, \key{Ins}.
Нажатие на клавишу-переключатель изменяет значение одного из разрядов в двухбайтовом слове, которое хранит состояние
клавиш-переключателей. Поэтому драйвер клавиатуры вначале должен проанализировать состояние этого слова,
а затем соответственно преобразовать коды.
\newpar

Клавиша \key{Ins} является единственной из клавиш-переключателей, нажатие которой не только заносит признак
в слово состояния переключателей, но и порождает передачу соответствующего кода драйверу терминала.
\newpar

С помощью ASCII-кодов можно представить 256 различных символов, а, значит, ASCII-коды можно сопоставить 256-ти кодам 
клавиш. Учитывая наличие клавиш-переключателей, комбинаций клавиш существует гораздо больше. Поэтому некоторые
комбинации клавиш драйвер клавиатуры преобразует в цепочки из нескольких байтов, так называемые Escape-последовательности,
в которых два первых байта служат признаком Escape-последовательности, а последующие представляют собой собственно значащие байты.
Escape-последовательности обычно представляют те комбинации клавиш, которые используются для управления работой програа, таких
как стрелки, клавиши \key{Page Down}, \key{Page Up}, \key{Home}, \key{End}, \key{F1}~--~\key{F12} и тд.
\newpar

В комплект \archlinux\ входит программа \linuxcommand{showkey}, которая показывает все три вида кодов, связанных с нажатиями
клавиш. Если запустить эту программу с параметром \linuxcommand{-s}, она будет показывать скан-коды нажатых клавиш.
Ввод команды \linuxcommand{showkey -k} приводит к выводу на экран кодов клавиш. Более подробное описание этой утилиты 
можно найти в \linuxcommand{man showkey}.


\subsection{Контроллер клавиатуры Intel 8042}
Контроллер \src{i8042} является контроллером клавиатуры, который связан с портом \src{PS/2} современных 
компьютеров, а так же с системной шиной. Обработка этого контроллера осуществляется функциями файла
\linuxpath{drivers/input/serio/i8042.h} ядра \linux. Порты ввода и вывода описаны в файле 
\linuxpath{drivers/input/serio/i8042-io.h}:
\begin{lstlisting}
#define I8042_COMMAND_REG	0x64
#define I8042_STATUS_REG	0x64
#define I8042_DATA_REG		0x60
\end{lstlisting}

Основная функция этого драйвера заключается в перехвате прерываний контроллера и начальная обработка 
нажатых клавиш. Далее код клавиши транслируется в подсистему ввода ядра.
\newpar

Однако порт \src{PS/2} обслуживает не только клавиатуру, но и мышь или touchpad. 
Соответственно, драйвер контроллера \src{i8042} обслуживает так же и их. Различает система
эти два различных устройства с помощью статусного байта, который считывается из порта 
\src{I8042\_STATUS\_REG}. Этот байт анализируется с помощью битовой маски
\src{I8042\_STR\_AUXDATA}, которая так же определена в \linuxpath{i8042.h} и определяет 
устрйство клавиатуры.
\newpar

Функция обработки прерывания контроллера так же позволяет фильтровать скан-коды сторонним
модулям:
\begin{lstlisting}
filtered = i8042_filter(data, str, serio);
spin_unlock_irqrestore(&i8042_lock, flags);
if (likely(port->exists && !filtered))
	serio_interrupt(serio, data, dfl);
\end{lstlisting}
где переменная \linuxcommand{filtered} является логической и содержит \linuxcommand{true}, если скан-код
был отфильтрован и \linuxcommand{false} иначе.
Инициализирован и деинициализирован обработчик-фильтр может быть с помощью глобальных функций из
заголовочного модуля \linuxpath{include/linux/i8042.h}:
\begin{lstlisting}
int i8042_install_filter(bool (*filter)(unsigned char data, 
	unsigned char str, struct serio *serio));
int i8042_remove_filter(bool (*filter)(unsigned char data, 
	unsigned char str, struct serio *serio));
\end{lstlisting}
Таким образом, написание драйвера-фильтра клавиатуры упирается лишь в написание
фильтр-функции, которая будет нужным образом обрабатывать входящие последовательности байтов.
Однако, фильтр-функция будет вызвана вне зависимости от того, прерывание от какого устройства
было принято драйвером: от клавиатуры или от мыши. Соответственно, драйвер-фильтр так же
обязан анализировать статусный регистр на предмет отношения к устройству.

\subsection{Расширенная клавиатура}
Дополнительной клавиатурой называется часть клавиатуры компьютера, расположенная
по левую руку от пользователя. В совокупности, основная и дополнительная клавиатуры называются
расширенной клавиатурой. Основную часть дополнительной клавиатуры составляют
расположенное в определенном порядке цифровые клавиши. Коды этих клавиш находятся в диапазоне
\src{0x47~-- 0x52}\footnote{Порядок следования кодов не соответствует исходному порядку цифр клавиатуры.
	Кроме того, некоторые коды из этого диапазона кодируют иные клавиши}, что позволяет системе
кодировать клавиши дополнительной клавиатуры на ровне с клавишами основной клавиатуры~-- с помощью
однобайтовой последовательности. 
\newpar

В свою очередь, такие специальные клавиши, как клавиши-стрелки, кодируются с помощью 2х-байтовой последовательности:
сначала контроллер посылает системе код \src{0xe0}, а затем~-- значащий код клавиши. Поэтому, коды клавиш 
\src{2, 4, 6, 8}\footnote{При выключенном \key{Num Lock} они осуществляют те же действия, что и клавиши-стрелки} 
совпадают с кодами клавиш-стрелок. Первый управляющий байт позволяет определить, какая клавиша в 
действительности была нажата.
\newpar

Для кодирования специальных клавиш клавиатуры компьютера так же используются однобайтовые коды.
Так, для кодирования клавиши \key{Shift} используется код \src{0x2a}. При этом, нажатие клавиши
\key{Shift} на уровне драйвера контроллера \src{i8042}, никак не отличается от кодирования клавиши \key{A}
или \key{B}. То есть, при нажатии на \key{Shift}, контроллер посылает драйверу сообщение с кодом \key{0x2a},
а при ее отжатии~-- \key{0xaa}. Разница заключается лишь в том, что, в отличии от основных клавиш клавиатуры компьютера,
время нажатия этой клавиши не учитывается драйвером терминала. То есть, если зажать клавишу \key{A} на 2~секунды,
драйвер терминала выведет на экран последовательность символов \key{a}, длина которой будет равна
\src{2 / (время отпускания)} секунд. Как правило, время отпускания клавиши~-- менее сотой доли секунды,
что дает в результате порядка 20ти символов. Клавиша \key{Shift} же не имеет такой особенности, что дает
очень большой выигрыш при программировании нажатий клавиш.
\newpar

Например, необходимо послать системе сообщение, что была нажата клавиша \key{(Заглавная) А}.
Для того, чтобы решить эту задачу, необходимо поступить следующим образом:
\begin{enumerate}
	\item Послать код нажатия клавиши \key{Shift} (\src{0x2a});
	\item Послать код нажатия клавиши \key{A} (\src{0x1e});
	\item Послать код отжатия клавиши \key{A} (\src{0x9e});
	\item Послать код отжатия клавиши \key{Shift} (\src{0xaa});
\end{enumerate}
\newpar

В виду того, что задержка отжатия клавиши \key{Shift} никак не учитывается системой,
результат будет абсолютно верным~--- система <<подумает>>, что была принята последовательность,
соответствующая символу \key{(Заглавная) A}, и выведет его на экран.

\subsection{Анализ работы клавиатуры кнопочного телефона}
Клавиатура обычного кнопочного телефона состоит из набора цифровых клавиш. Каждой цифровой клавише
телефона соответствует несколько буквенных символов. При вводе текста
с помощью такой клавиатуры, система телефона подсчитывает задержки, которые прошли с момента
последнего нажатия последней кнопки. При истечении времени задержки счетчик введенных символов сбрасывается,
что позволяет осуществить ввод второго символа, находящегося на одной и той же клавише.
Например, для ввода слова \src{programming} с помощью такой клавиатуры, необходимо
осуществить следующие нажатия клавиш\footnote{Действительно для мобильного телефона модели
Motorolla RAZR V3r} (нижним подчеркиванием обозначена задержка в нажатии):\par\src{7\_777666477726\_6444664}
\newpar

Помимо буквенных символов, клавиатура кнопочного телефона так же позволяет вводить и цифры.
Как правило, на клавише \key{1} кнопочной клавиатуры, располагается набор знаков препинания.
В зависимости от модели телефона, пробел может находиться на \key{1}, \key{0}, \key{*} или \key{\#}.
В данном драйвере так же на клавишу \key{1} привязан набор знаков препинания. Пробел привязан
к клавише \key{0}. При этом, ради удобства пользователя происходит вертикальная инверсия 
цифр дополнительной цифровой клавиатуры компьютера. То есть клавише \key{7} клавиатуры компьютера
соответствует клавиша \key{1} клавиатуры телефона, клавише \key{9}~-- \key{3}, \key{1}~-- \key{7}.

\subsection{Системный таймер} \label{sec:jiffies}
\subsubsection{Частота импульсов таймера: \src{HZ}}
Частота системного таймера (частота импульсов) программируется при загрузке системы на основании
параметра \src{HZ}, который определен с помощью директивы препроцессора.
Значение параметра \src{HZ} отличается для различных поддерживаемых аппаратных платформ. На самом деле,
для некоторых аппаратных платформ значение параметра \src{HZ} отличается даже для разных типов машин.
\newpar

Данный параметр ядра определен в файле \linuxpath{asm/param.h}. Частота системного таймера равна значению параметра \src{HZ},
период таймера равен \src{1/HZ}. Например, в файле \src{<include/asm-i386/param.h>} для аппаратной платформы
\src{i386} этот параметр определен следующим образом:
\begin{lstlisting}
#define HZ 1000 /* internal kernel time frequency */
\end{lstlisting}

Поэтому для аппаратной платформы \src{i386} прерывание таймера генерируется с частотой 1000 Гц, т.е. 1000 раз в секунду.
Для большинства других аппаратных платформ значение частоты системного таймера равно 100 Гц.
\newpar

Увеличение значения частоты системного таймера означает, что обработчик прерывания таймера
выполняется более часто. Это позволяет получить следующие преимущества:
\begin{itemize}
	\item Прерывание таймера имеет большую разрешающую способность по времени, и
		следовательно, все события, которые выполняются во времени, также имеют большую 
		разрешающую способность.
	\item Увеличивается точность выполнения событий во времени.
\end{itemize}

Разрешающая способность увеличивается во столько же раз, во сколько раз возрастает
частота импульсов. Например, гранулярность таймеров при частоте 100 Гц равна 10 миллисекунд. Другими
словами, все периодические события выполняются прерыванием таймера, которое генерируется с предельной точностью
по времени, равной 10 миллисекунд, и большая точность не гарантируется. При частоте 1000 Гц, разрешающая
способность равна 1 миллисекунде, т.е. в 10 раз выше. Хотя ядро позволяет создавать таймеры с временным
разрешением, равным 1 миллисекунде, однако при частоте системного таймера в 100 Гц нет возможности
гарантированно получить временной интервал, короче 10 миллисекунд.
\newpar

Более высокое разрешение и большая точность обеспечивают следующие преимущества:
\begin{itemize}
	\item Таймеры ядра выполняются с большим разрешением и с лучшей точностью
	\item Системные вызовы, такие как \src{poll()}%
\footnote{Системный вызов \src{poll()} ожидает наступления некоторого события в файловой системе} и \src{select()}%
\footnote{Системный вызов \src{select()} ожидает изменения статуса нескольких файловых описателей}, 
		которые позволяют при желании использовать время ожидания (\src{timeout}) в 
		качестве параметра, выполняются с большей точностью
	\item Измерения, такие как учет использования ресурсов или измерения времени работы системы, выполняются
		с большей точностью
	\item Вытеснение процессов выполняется более правильно
\end{itemize}

Однако, существует и обратная сторона увеличения частоты системного таймера, иначе она была бы с самого начала равна
1000 Гц (или даже больше). Более высокая частота вызывает более частые прерывания таймера, что означает большие накладные
затраты. Чем выше частота, тем больше времени процессор должен тратить на выполнение прерываний таймера. Это приводит
не только к тому, что другим задачам отводится меньше процессорного времени, но и к периодическому трешингу (trashing) кэша
процессора\footnote{т.е. кэш заполняется данными, которые не используются процессором}. Проблема, связанная
с накладными расходами, вызывает споры. Не ясно от какого  реального значения накладных затрат следует отталкиваться.
Решающее соглашение состоит в том, что по крайней мере для современных систем, значение параметра \src{HZ=1000}
не приводит к недопустимым накладным затратам.

\subsubsection{Переменная \src{jiffies}}
Глобальная переменная \src{jiffies}\footnote{В вычислительной технике термин \src{jiffi}~-- это обычно интервал
времени между двумя соседними импульсами системного таймера, которые были успешно обработаны} 
содержит количество импульсов системного таймера, которые были получены
со времени загрузки системы. При загрузке ядро устанавливает значение этого параметра в нуль и он увеличивается
на еденицу при каждом прерывании системного таймера. Так как в секунду возникает \src{HZ} прерываний
системного таймера, то за секунду значение переменной \src{jiffies} увеличивается на \src{HZ}. Время работы
системы (\src{uptime}) поэтому равно \src{jiffies~/~HZ} секунд.
\newpar

Переменная \src{jiffies} определена в файле \src{<linux/jiffies.h>} следующим образом:
\begin{lstlisting}
extern unsigned long volatile jiffies;
\end{lstlisting}
Ядро представляет четыре макроса для сравнения двух значений счетчика импульсов таймера,
которые корректно обрабатывают переполнения счетчиков. Они определены в файле
\src{linux/jiffies.h} следующим образом:
\begin{lstlisting} 
#define time_after(unknown, known) \     
		((long)(known) - (long)(unknown) < 0)
#define time_before(unknown, known) \
		((long)(unknown) - (long)(known) < 0)
#define time_after_eq(unknown, known) \   
		((long)(unknown) - (long)(known) >= 0)
#define time_before_eq(unknown, known) \
		((long)(known) - (long)(unknown) >= 0)
\end{lstlisting}
Параметр \src{unknown}~-- это обычно значение переменной \src{jiffies}, а параметр
\src{known}~-- значение, с которым его необходимо сравнивать.
\newpar

Макрос \src{time\_after(unknown, known)} возвращает значение \src{true}, если момент
времени \src{unknown} происходит после момента времени \src{known}, в противном случае
возвращается значение \src{false}. Макрос \src{time\_before(unknown, known)} возвращает 
значение \src{true}, если момент времени \src{unknown} происходит раньше, чем момент
времени \src{known}, в противном случае возвращается значение \src{false}. Последние два
макроса работают аналогично первым двум, за исключением того, что возвращается
значение <<истинно>>, если оба параметра равны друг другу.
Необходимость в использовании этих макросов может возникнуть в случае переполнения
переменной \src{jiffies}\footnote{Для значения \src{HZ=1000} и 32х-разрядного значения переменной \src{jiffies},
переполнение может наступить уже через 47.9 дней}.
\newpage
